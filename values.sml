(**************************************************************************)
(**************************************************************************)
(***                                                                    ***)
(***    Values generated by Rebecca programs:                           ***)
(***                                                                    ***)
(**************************************************************************)
(**************************************************************************)

structure Values:
  sig
        type value

(* tjt, Jan 2014 *)
        val CONSTANT : Rubytype.const           -> value
        val CIRCUIT  : (unit->Circuittype.circuit) -> value
        val FUNCTION : (value->value)  -> value

        val value2circuit : value -> Circuittype.circuit
        val value2const   : value -> Rubytype.const
	val value2bool    : value -> bool
        val value2num     : value -> Rubytype.const
        val value2int     : value -> int
        val value2nat     : value -> int
        val apply         : (value * value list) -> (value * value list)
  end =
struct

(**************************************************************************)
(**************************************************************************)
(***                                                                    ***)
(***    An irreducible value in the Rebecca language is either a        ***)
(***    constant, or a function which creates an instance of a circuit, ***)
(***    or a function mapping values to values:                         ***)
(***                                                                    ***)
(**************************************************************************)

datatype value = CONSTANT of Rubytype.const
               | CIRCUIT  of unit -> Circuittype.circuit
(* tjt, Jan 2014 *)
               | FUNCTION of value -> value

(**************************************************************************)
(***                                                                    ***)
(***    These functions convert values to the particular types of       ***)
(***    required by primitives:                                         ***)
(***                                                                    ***)
(**************************************************************************)

(* tjt, Jan 2014 *)
fun prim_error s = Errors.def_error ("\"" ^ !State.CurrentPrim ^ "\" applied to " ^ s)

fun value2circuit (CONSTANT d) = let  val e = Exprs.con d
                                 in   (e, e, [])
                                 end
  | value2circuit (CIRCUIT c)  = c ()
  | value2circuit (FUNCTION _) = prim_error "function"

fun value2const (CONSTANT d) = d
  | value2const (CIRCUIT  _) = prim_error "circuit"
  | value2const (FUNCTION _) = prim_error "function"

fun value2num v = let  val k = value2const v
                  in   (case k of
                          Rubytype.INT _  => k
                        | Rubytype.REAL _ => k
                        | Rubytype.SYM _  => prim_error "symbol"
                        | Rubytype.BOOL _ => prim_error "boolean"
(* tjt, Jan 2014 *)
                       )
                  end

fun value2bool v = (case value2num v of
                      Rubytype.INT _      => prim_error "integer"
                    | Rubytype.REAL _     => prim_error "real number"
                    | Rubytype.SYM _      => prim_error "symbol"
                    | Rubytype.BOOL b     => b
                   )

fun value2int v = (case value2num v of
                     Rubytype.INT i      => i
                   | Rubytype.REAL _     => prim_error "real number"
                   | Rubytype.SYM _      => prim_error "symbol"
                   | Rubytype.BOOL _     => prim_error "boolean"
                  )

fun value2nat v = let  val i = value2int v
                  in   if    i>=0
                       then  i
                       else  prim_error "negative integer"
                  end

(**************************************************************************)
(***                                                                    ***)
(***    This function applies a value to as many elements of a list of  ***)
(***    as is possible, returning the result of the application and the ***)
(***    remaining un-applied-to elements of the list                    ***)
(***                                                                    ***)
(**************************************************************************)

fun apply (FUNCTION f, x::xs) = apply (f x, xs)
  | apply vxs                 = vxs

(**************************************************************************)
(**************************************************************************)

end (* of struct Values *);
(* open Values *)
