#!/usr/bin/expect -f
#
# This Expect script was generated by autoexpect on Mon Jan 28 15:37:43 2013
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don


set timeout -1
spawn $env(SHELL)
match_max 100000
expect -exact "\[80G  \r\[1;43madvantage: ~/ruby/compiler% \[0m \[80G  \r> "
send -- "sml\r"
expect -exact "sml\r\r
Standard ML of New Jersey v110.69 \[built: Mon Jun  8 23:24:21 2009\]\r
- "
send -- "use \"all_open_build\";\r"
expect -exact "use \"all_open_build\";\r
\[opening all_open_build\]\r
\[opening utilities.sml\]\r
\[autoloading\]\r
\[library \$SMLNJ-BASIS/basis.cm is stable\]\r
\[autoloading done\]\r
utilities.sml:123.30 Warning: calling polyEqual\r
utilities.sml:114.28 Warning: calling polyEqual\r
utilities.sml:106.60 Warning: calling polyEqual\r
utilities.sml:84.26-84.28 Warning: calling polyEqual\r
utilities.sml:81.23 Warning: calling polyEqual\r
utilities.sml:76.36 Warning: calling polyEqual\r
structure Utilities :\r
  sig\r
    val flatmap : ('a -> 'b list) -> 'a list -> 'b list\r
    val concat : 'a list list -> 'a list\r
    val sum : int list -> int\r
    val listmax : int list -> int\r
    val zip : 'a list * 'b list -> ('a * 'b) list\r
    val unzip : ('a * 'b) list -> 'a list * 'b list\r
    val for : int * int -> (int -> 'a) -> 'a list\r
    val pairWithIntsFrom : int -> 'a list -> ('a * int) list\r
    val occurrences : ''a -> ''a list -> int\r
    val elem : ''a -> ''a list -> bool\r
    val notElem : ''a -> ''a list -> bool\r
    val remdups : ''a list -> ''a list\r
    val orderedRemdups : ''a list -> ''a list\r
    val remduprefs : ''a ref list -> ''a ref list\r
    val orderedRemduprefs : ''a ref list -> ''a ref list\r
    val tjt97remDupRefs : ''a ref list -> ''a ref list\r
    val take : int * 'a list -> 'a list\r
    val drop : int * 'a list -> 'a list\r
    val takewhile : ('a -> bool) -> 'a list -> 'a list\r
    val dropwhile : ('a -> bool) -> 'a list -> 'a list\r
    val takeuntil : ('a -> bool) -> 'a list -> 'a list\r
    val filter : ('a -> bool) -> 'a list -> 'a list\r
    val concatWith : string -> string list -> string\r
    val ljustify : int -> string -> string\r
    val rjustify : int -> string -> string\r
    val fileContents : string -> string\r
    val array2list : 'a array -> 'a list\r
  end\r
val it = () : unit\r
opening Utilities\r
  val flatmap : ('a -> 'b list) -> 'a list -> 'b list\r
  val concat : 'a list list -> 'a list\r
  val sum : int list -> int\r
  val listmax : int list -> int\r
  val zip : 'a list * 'b list -> ('a * 'b) list\r
  val unzip : ('a * 'b) list -> 'a list * 'b list\r
  val for : int * int -> (int -> 'a) -> 'a list\r
  val pairWithIntsFrom : int -> 'a list -> ('a * int) list\r
  val occurrences : ''a -> ''a list -> int\r
  val elem : ''a -> ''a list -> bool\r
  val notElem : ''a -> ''a list -> bool\r
  val remdups : ''a list -> ''a list\r
  val orderedRemdups : ''a list -> ''a list\r
  val remduprefs : ''a ref list -> ''a ref list\r
  val orderedRemduprefs : ''a ref list -> ''a ref list\r
  val tjt97remDupRefs : ''a ref list -> ''a ref list\r
  val take : int * 'a list -> 'a list\r
  val drop : int * 'a list -> 'a list\r
  val takewhile : ('a -> bool) -> 'a list -> 'a list\r
  val dropwhile : ('a -> bool) -> 'a list -> 'a list\r
  val takeuntil : ('a -> bool) -> 'a list -> 'a list\r
  val filter : ('a -> bool) -> 'a list -> 'a list\r
  val concatWith : string -> string list -> string\r
  val ljustify : int -> string -> string\r
  val rjustify : int -> string -> string\r
  val fileContents : string -> string\r
  val array2list : 'a array -> 'a list\r
\[opening maybe.sml\]\r
maybe.sml:32.5-32.21 Warning: match nonexhaustive\r
          Ok x => ...\r
  \r
structure Maybe :\r
  sig\r
    datatype 'a maybe = ...\r
    val success : 'a -> 'a maybe\r
    val failure : 'a maybe\r
    val successful : 'a maybe -> bool\r
    val the : 'a maybe -> 'a\r
  end\r
val it = () : unit\r
opening Maybe\r
  datatype 'a maybe = ...\r
  val success : 'a -> 'a maybe\r
  val failure : 'a maybe\r
  val successful : 'a maybe -> bool\r
  val the : 'a maybe -> 'a\r
\[opening mappings.sml\]\r
mappings.sml:36.47 Warning: calling polyEqual\r
structure Mappings :\r
  sig\r
    type ('a,'b) mapping = 'a -> 'b\r
    type ('a,'b) table = ('a,'b) mapping array\r
    val nullMapping : (''a,'b) mapping\r
    val extendMapping : (''a * 'b) * (''a,'b) mapping -> (''a,'b) mapping\r
    val pairs2mapping : (''a * 'b) list -> (''a,'b) mapping\r
    val newTable : int -> (string,'a) table\r
    val store : (string,'a) table -> string * 'a -> unit\r
    val lookup : (string,'a) table -> string -> 'a maybe\r
  end\r
val it = () : unit\r
opening Mappings\r
  type ('a,'b) mapping = 'a -> 'b\r
  type ('a,'b) table = ('a,'b) Mappings.mapping array\r
  val nullMapping : (''a,'b) mapping\r
  val extendMapping : (''a * 'b) * (''a,'b) mapping -> (''a,'b) mapping\r
  val pairs2mapping : (''a * 'b) list -> (''a,'b) mapping\r
  val newTable : int -> (string,'a) table\r
  val store : (string,'a) table -> string * 'a -> unit\r
  val lookup : (string,'a) table -> string -> 'a maybe\r
\[opening state.sml\]\r
structure State :\r
  sig\r
    val SourceFiles : string list ref\r
    val IncludeFiles : string list ref\r
    val FunStack : string list ref\r
    val CurrentPrim : string ref\r
    val Testing : bool ref\r
    val DefTabSize : int\r
    val pushFun : string -> unit\r
    val popFun : string -> unit\r
  end\r
val it = () : unit\r
opening State\r
  val SourceFiles : string list ref\r
  val IncludeFiles : string list ref\r
  val FunStack : string list ref\r
  val CurrentPrim : string ref\r
  val Testing : bool ref\r
  val DefTabSize : int\r
  val pushFun : string -> unit\r
  val popFun : string -> unit\r
\[opening errors.sml\]\r
structure Errors :\r
  sig\r
    exception DEF_ERROR of string\r
    exception SIMPLE_ERROR of string\r
    exception SEQ_ERROR of string\r
    exception USAGE_ERROR of string\r
    exception LEX_ERROR of string\r
    exception PARSE_ERROR of string\r
    exception LOOP_ERROR of string list\r
    val TextPosition : (int * int) ref\r
    val def_error : string -> 'a\r
    val simple_error : string -> 'a\r
    val seq_error : string -> 'a\r
    val usage_error : string -> 'a\r
    val lex_error : (int * int) * string -> 'a\r
    val parse_error : string * (int * int) * (int * int) -> 'a\r
    val loop_error : string list -> 'a\r
  end\r
val it = () : unit\r
opening Errors\r
  exception DEF_ERROR of string\r
  exception SIMPLE_ERROR of string\r
  exception SEQ_ERROR of string\r
  exception USAGE_ERROR of string\r
  exception LEX_ERROR of string\r
  exception PARSE_ERROR of string\r
  exception LOOP_ERROR of string list\r
  val TextPosition : (int * int) ref\r
  val def_error : string -> 'a\r
  val simple_error : string -> 'a\r
  val seq_error : string -> 'a\r
  val usage_error : string -> 'a\r
  val lex_error : (int * int) * string -> 'a\r
  val parse_error : string * (int * int) * (int * int) -> 'a\r
  val loop_error : string list -> 'a\r
\[opening messages.sml\]\r
\[autoloading\]\r
\[autoloading done\]\r
messages.sml:31.5-60.94 Warning: match nonexhaustive\r
          SIMPLE_ERROR s => ...\r
          LEX_ERROR s => ...\r
          PARSE_ERROR s => ...\r
          SEQ_ERROR s => ...\r
          DEF_ERROR s => ...\r
          LOOP_ERROR ds => ...\r
          USAGE_ERROR s => ...\r
          Io {cause=cause,function=function,name=name} => ...\r
  \r
structure Messages : sig val message : exn -> string end\r
val it = () : unit\r
opening Messages\r
  val message : exn -> string\r
\[opening rubytype.sml\]\r
structure Rubytype :\r
  sig\r
    datatype defn\r
      = Ddefn of string * io\r
      | Fdefn of string * string list * exp\r
      | Include of string\r
    datatype exp\r
      = App of string * exp list\r
      | Const of const\r
      | Let of (string * exp) list * exp\r
      | Par of exp list\r
      | Rel of (int * int) * string list * appexp * appexp\r
      | Select of exp * exp list\r
      | Seq of (int * int) * exp * exp\r
      | Var of string\r
      | Wiring of io * io\r
    datatype const = BOOL of bool | INT of int | REAL of real | SYM of string\r
    datatype io = CONST of const | PROD of io list | VAR of string\r
    datatype appexp\r
      = aAPP of exp * appexp\r
      | aCONST of const\r
      | aPROD of appexp list\r
      | aVAR of string\r
  end\r
val it = () : unit\r
opening Rubytype\r
  \r
  datatype defn\r
    = Ddefn of string * Rubytype.io\r
    | Fdefn of string * string list * Rubytype.exp\r
    | Include of string\r
  datatype exp\r
    = App of string * Rubytype.exp list\r
    | Const of Rubytype.const\r
    | Let of (string * Rubytype.exp) list * Rubytype.exp\r
    | Par of Rubytype.exp list\r
    | Rel of (int * int) * string list * Rubytype.appexp * Rubytype.appexp\r
    | Select of Rubytype.exp * Rubytype.exp list\r
    | Seq of (int * int) * Rubytype.exp * Rubytype.exp\r
    | Var of string\r
    | Wiring of Rubytype.io * Rubytype.io\r
  datatype const = BOOL of bool | INT of int | REAL of real | SYM of string\r
  datatype io\r
    = CONST of Rubytype.const | PROD of Rubytype.io list | VAR of string\r
  datatype appexp\r
    = aAPP of Rubytype.exp * Rubytype.appexp\r
    | aCONST of Rubytype.const\r
    | aPROD of Rubytype.appexp list\r
    | aVAR of string\r
\[opening ios.sml\]\r
structure Ios : sig val iovars : io -> string list end\r
val it = () : unit\r
opening Ios\r
  val iovars : io -> string list\r
\[opening base.sml\]\r
signature STREAM =\r
  sig\r
    type 'a stream\r
    val streamify : (unit -> 'a) -> 'a stream\r
    val cons : 'a * 'a stream -> 'a stream\r
    val get : 'a stream -> 'a * 'a stream\r
  end\r
signature LR_TABLE =\r
  sig\r
    datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist\r
    datatype state = STATE of int\r
    datatype term = T of int\r
    datatype nonterm = NT of int\r
    datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state\r
    type table\r
    val numStates : table -> int\r
    val numRules : table -> int\r
    val describeActions : table -> state -> (term,action) pairlist * action\r
    val describeGoto : table -> state -> (nonterm,state) pairlist\r
    val action : table -> state * term -> action\r
    val goto : table -> state * nonterm -> state\r
    val initialState : table -> state\r
    exception Goto of state * nonterm\r
    val mkLrTable : {actions:((term,action) pairlist * action) array,\r
                     gotos:(nonterm,state) pairlist array, initialState:state,\r
                     numRules:int, numStates:int}\r
                    -> table\r
  end\r
signature TOKEN =\r
  sig\r
    structure LrTable :\r
      sig\r
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist\r
        datatype state = STATE of int\r
        datatype term = T of int\r
        datatype nonterm = NT of int\r
        datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state\r
        type table\r
        val numStates : table -> int\r
        val numRules : table -> int\r
        val describeActions : table\r
                              -> state -> (term,action) pairlist * action\r
        val describeGoto : table -> state -> (nonterm,state) pairlist\r
        val action : table -> state * term -> action\r
        val goto : table -> state * nonterm -> state\r
        val initialState : table -> state\r
        exception Goto of state * nonterm\r
        val mkLrTable : {actions:((term,action) pairlist * action) array,\r
                         gotos:(nonterm,state) pairlist array,\r
                         initialState:state, numRules:int, numStates:int}\r
                        -> table\r
      end\r
    datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)\r
    val sameToken : ('a,'b) token * ('a,'b) token -> bool\r
  end\r
signature LR_PARSER =\r
  sig\r
    structure Stream :\r
      sig\r
        type 'a stream\r
        val streamify : (unit -> 'a) -> 'a stream\r
        val cons : 'a * 'a stream -> 'a stream\r
        val get : 'a stream -> 'a * 'a stream\r
      end\r
    structure LrTable :\r
      sig\r
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist\r
        datatype state = STATE of int\r
        datatype term = T of int\r
        datatype nonterm = NT of int\r
        datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state\r
        type table\r
        val numStates : table -> int\r
        val numRules : table -> int\r
        val describeActions : table\r
                              -> state -> (term,action) pairlist * action\r
        val describeGoto : table -> state -> (nonterm,state) pairlist\r
        val action : table -> state * term -> action\r
        val goto : table -> state * nonterm -> state\r
        val initialState : table -> state\r
        exception Goto of state * nonterm\r
        val mkLrTable : {actions:((term,action) pairlist * action) array,\r
                         gotos:(nonterm,state) pairlist array,\r
                         initialState:state, numRules:int, numStates:int}\r
                        -> table\r
      end\r
    structure Token :\r
      sig\r
        structure LrTable : <sig>\r
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)\r
        val sameToken : ('a,'b) token * ('a,'b) token -> bool\r
      end\r
    exception ParseError\r
    val parse : {arg:'a,\r
                 ec:{error:string * 'c * 'c -> unit,\r
                     errtermvalue:LrTable.term -> 'b,\r
                     is_keyword:LrTable.term -> bool,\r
                     noShift:LrTable.term -> bool,\r
                     preferred_insert:LrTable.term -> bool,\r
                     preferred_subst:LrTable.term -> LrTable.term list,\r
                     showTerminal:LrTable.term -> string,\r
                     terms:LrTable.term list},\r
                 lexer:('b,'c) Token.token Stream.stream, lookahead:int,\r
                 saction:int * 'c * (LrTable.state * ('b * 'c * 'c)) list * 'a\r
                         -> LrTable.nonterm * ('b * 'c * 'c) * \r
                            (LrTable.state * ('b * 'c * 'c)) list,\r
                 table:LrTable.table, void:'b}\r
                -> 'b * ('b,'c) Token.token Stream.stream\r
    sharing Token.LrTable = LrTable\r
  end\r
signature LEXER =\r
  sig\r
    structure UserDeclarations :\r
      sig\r
        type ('a,'b) token\r
        type pos\r
        type svalue\r
      end\r
    val makeLexer : (int -> string)\r
                    -> unit\r
                       -> (UserDeclarations.svalue,UserDeclarations.pos) \r
                            UserDeclarations.token\r
  end\r
signature ARG_LEXER =\r
  sig\r
    structure UserDeclarations :\r
      sig\r
        type ('a,'b) token\r
        type pos\r
        type svalue\r
        type arg\r
      end\r
    val makeLexer : (int -> string)\r
                    -> UserDeclarations.arg\r
                       -> unit\r
                          -> (UserDeclarations.svalue,UserDeclarations.pos) \r
                               UserDeclarations.token\r
  end\r
signature PARSER_DATA =\r
  sig\r
    type pos\r
    type svalue\r
    type arg\r
    type result\r
    structure LrTable :\r
      sig\r
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist\r
        datatype state = STATE of int\r
        datatype term = T of int\r
        datatype nonterm = NT of int\r
        datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state\r
        type table\r
        val numStates : table -> int\r
        val numRules : table -> int\r
        val describeActions : table\r
                              -> state -> (term,action) pairlist * action\r
        val describeGoto : table -> state -> (nonterm,state) pairlist\r
        val action : table -> state * term -> action\r
        val goto : table -> state * nonterm -> state\r
        val initialState : table -> state\r
        exception Goto of state * nonterm\r
        val mkLrTable : {actions:((term,action) pairlist * action) array,\r
                         gotos:(nonterm,state) pairlist array,\r
                         initialState:state, numRules:int, numStates:int}\r
                        -> table\r
      end\r
    structure Token :\r
      sig\r
        structure LrTable : <sig>\r
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)\r
        val sameToken : ('a,'b) token * ('a,'b) token -> bool\r
      end\r
    structure Actions :\r
      sig\r
        val actions : int * pos * (LrTable.state * (svalue * pos * pos)) list\r
                      * arg\r
                      -> LrTable.nonterm * (svalue * pos * pos) * \r
                         (LrTable.state * (svalue * pos * pos)) list\r
        val void : svalue\r
        val extract : svalue -> result\r
      end\r
    structure EC :\r
      sig\r
        val is_keyword : LrTable.term -> bool\r
        val noShift : LrTable.term -> bool\r
        val preferred_subst : LrTable.term -> LrTable.term list\r
        val preferred_insert : LrTable.term -> bool\r
        val errtermvalue : LrTable.term -> svalue\r
        val showTerminal : LrTable.term -> string\r
        val terms : LrTable.term list\r
      end\r
    val table : LrTable.table\r
    sharing LrTable = Token.LrTable\r
  end\r
signature PARSER =\r
  sig\r
    structure Token :\r
      sig\r
        structure LrTable : <sig>\r
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)\r
        val sameToken : ('a,'b) token * ('a,'b) token -> bool\r
      end\r
    structure Stream :\r
      sig\r
        type 'a stream\r
        val streamify : (unit -> 'a) -> 'a stream\r
        val cons : 'a * 'a stream -> 'a stream\r
        val get : 'a stream -> 'a * 'a stream\r
      end\r
    exception ParseError\r
    type pos\r
    type result\r
    type arg\r
    type svalue\r
    val makeLexer : (int -> string) -> (svalue,pos) Token.token Stream.stream\r
    val parse : int * (svalue,pos) Token.token Stream.stream * \r
                (string * pos * pos -> unit) * arg\r
                -> result * (svalue,pos) Token.token Stream.stream\r
    val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token\r
                    -> bool\r
  end\r
signature ARG_PARSER =\r
  sig\r
    structure Token :\r
      sig\r
        structure LrTable : <sig>\r
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)\r
        val sameToken : ('a,'b) token * ('a,'b) token -> bool\r
      end\r
    structure Stream :\r
      sig\r
        type 'a stream\r
        val streamify : (unit -> 'a) -> 'a stream\r
        val cons : 'a * 'a stream -> 'a stream\r
        val get : 'a stream -> 'a * 'a stream\r
      end\r
    exception ParseError\r
    type arg\r
    type lexarg\r
    type pos\r
    type result\r
    type svalue\r
    val makeLexer : (int -> string)\r
                    -> lexarg -> (svalue,pos) Token.token Stream.stream\r
    val parse : int * (svalue,pos) Token.token Stream.stream * \r
                (string * pos * pos -> unit) * arg\r
                -> result * (svalue,pos) Token.token Stream.stream\r
    val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token\r
                    -> bool\r
  end\r
structure Stream : STREAM\r
structure LrTable : LR_TABLE\r
functor Join(<param>: sig\r
                        structure Lex : <sig>\r
                        structure ParserData : <sig>\r
                        structure LrParser : <sig>\r
                        sharing LrParser.Token = ParserData.Token\r
                        sharing LrParser.LrTable = ParserData.LrTable\r
                        sharing type ParserData.Token.token = \r
                                     Lex.UserDeclarations.token\r
                        sharing type ParserData.pos = Lex.UserDeclarations.pos\r
                        sharing type ParserData.svalue = \r
                                     Lex.UserDeclarations.svalue\r
                      end) :\r
            sig\r
              structure Token : <sig>\r
              structure Stream : <sig>\r
              exception ParseError\r
              type pos\r
              type result\r
              type arg\r
              type svalue\r
              val makeLexer : (int -> string)\r
                              -> (svalue,pos) Token.token Stream.stream\r
              val parse : int * (svalue,pos) Token.token Stream.stream * \r
                          (string * pos * pos -> unit) * arg\r
                          -> result * (svalue,pos) Token.token Stream.stream\r
              val sameToken : (svalue,pos) Token.token * \r
                              (svalue,pos) Token.token\r
                              -> bool\r
            end\r
functor JoinWithArg(<param>: sig\r
                               structure Lex : <sig>\r
                               structure ParserData : <sig>\r
                               structure LrParser : <sig>\r
                               sharing LrParser.Token = ParserData.Token\r
                               sharing LrParser.LrTable = ParserData.LrTable\r
                               sharing type ParserData.Token.token = \r
                                            Lex.UserDeclarations.token\r
                               sharing type ParserData.pos = \r
                                            Lex.UserDeclarations.pos\r
                               sharing type ParserData.svalue = \r
                                            Lex.UserDeclarations.svalue\r
                             end) :\r
                   sig\r
                     structure Token : <sig>\r
                     structure Stream : <sig>\r
                     exception ParseError\r
                     type arg\r
                     type lexarg\r
                     type pos\r
                     type result\r
                     type svalue\r
                     val makeLexer : (int -> string)\r
                                     -> lexarg\r
                                        -> (svalue,pos) Token.token \r
                                             Stream.stream\r
                     val parse : int * (svalue,pos) Token.token Stream.stream\r
                                 * (string * pos * pos -> unit) * arg\r
                                 -> result * \r
                                    (svalue,pos) Token.token Stream.stream\r
                     val sameToken : (svalue,pos) Token.token * \r
                                     (svalue,pos) Token.token\r
                                     -> bool\r
                   end\r
base.sml:934.50 Warning: calling polyEqual\r
base.sml:593.61 Warning: calling polyEqual\r
signature FIFO =\r
  sig\r
    type 'a queue\r
    val empty : 'a queue\r
    exception Empty\r
    val get : 'a queue -> 'a * 'a queue\r
    val put : 'a * 'a queue -> 'a queue\r
  end\r
structure LrParser : LR_PARSER\r
val it = () : unit\r
\[opening ruby.yacc.sig\]\r
signature Ruby_TOKENS =\r
  sig\r
    type ('a,'b) token\r
    type svalue\r
    val EOF : 'a * 'a -> (svalue,'a) token\r
    val FLOAT : real * 'a * 'a -> (svalue,'a) token\r
    val INTEGER : int * 'a * 'a -> (svalue,'a) token\r
    val BOOLEAN : bool * 'a * 'a -> (svalue,'a) token\r
    val DID : string * 'a * 'a -> (svalue,'a) token\r
    val ID : string * 'a * 'a -> (svalue,'a) token\r
    val SYMBOL : string * 'a * 'a -> (svalue,'a) token\r
    val POSTFIX : string * 'a * 'a -> (svalue,'a) token\r
    val INFIX : string * 'a * 'a -> (svalue,'a) token\r
    val PRODUCT : string * 'a * 'a -> (svalue,'a) token\r
    val SUM : string * 'a * 'a -> (svalue,'a) token\r
    val NEG : string * 'a * 'a -> (svalue,'a) token\r
    val QUOTE : 'a * 'a -> (svalue,'a) token\r
    val SEMICOLON : (int * int) * 'a * 'a -> (svalue,'a) token\r
    val REL : (int * int) * 'a * 'a -> (svalue,'a) token\r
    val VAR : 'a * 'a -> (svalue,'a) token\r
    val ELSE : 'a * 'a -> (svalue,'a) token\r
    val THEN : 'a * 'a -> (svalue,'a) token\r
    val IF : 'a * 'a -> (svalue,'a) token\r
    val END : 'a * 'a -> (svalue,'a) token\r
    val IN : 'a * 'a -> (svalue,'a) token\r
    val LET : 'a * 'a -> (svalue,'a) token\r
    val RBKT : 'a * 'a -> (svalue,'a) token\r
    val LBKT : 'a * 'a -> (svalue,'a) token\r
    val SELECT : 'a * 'a -> (svalue,'a) token\r
    val INCLUDE : 'a * 'a -> (svalue,'a) token\r
    val WIRE : 'a * 'a -> (svalue,'a) token\r
    val COMMA : 'a * 'a -> (svalue,'a) token\r
    val DOT : 'a * 'a -> (svalue,'a) token\r
    val EQUAL : 'a * 'a -> (svalue,'a) token\r
    val RANGLE : 'a * 'a -> (svalue,'a) token\r
    val LANGLE : 'a * 'a -> (svalue,'a) token\r
    val LPAREN : 'a * 'a -> (svalue,'a) token\r
    val RPAREN : 'a * 'a -> (svalue,'a) token\r
  end\r
signature Ruby_LRVALS =\r
  sig\r
    structure Tokens :\r
      sig\r
        type ('a,'b) token\r
        type svalue\r
        val EOF : 'a * 'a -> (svalue,'a) token\r
        val FLOAT : real * 'a * 'a -> (svalue,'a) token\r
        val INTEGER : int * 'a * 'a -> (svalue,'a) token\r
        val BOOLEAN : bool * 'a * 'a -> (svalue,'a) token\r
        val DID : string * 'a * 'a -> (svalue,'a) token\r
        val ID : string * 'a * 'a -> (svalue,'a) token\r
        val SYMBOL : string * 'a * 'a -> (svalue,'a) token\r
        val POSTFIX : string * 'a * 'a -> (svalue,'a) token\r
        val INFIX : string * 'a * 'a -> (svalue,'a) token\r
        val PRODUCT : string * 'a * 'a -> (svalue,'a) token\r
        val SUM : string * 'a * 'a -> (svalue,'a) token\r
        val NEG : string * 'a * 'a -> (svalue,'a) token\r
        val QUOTE : 'a * 'a -> (svalue,'a) token\r
        val SEMICOLON : (int * int) * 'a * 'a -> (svalue,'a) token\r
        val REL : (int * int) * 'a * 'a -> (svalue,'a) token\r
        val VAR : 'a * 'a -> (svalue,'a) token\r
        val ELSE : 'a * 'a -> (svalue,'a) token\r
        val THEN : 'a * 'a -> (svalue,'a) token\r
        val IF : 'a * 'a -> (svalue,'a) token\r
        val END : 'a * 'a -> (svalue,'a) token\r
        val IN : 'a * 'a -> (svalue,'a) token\r
        val LET : 'a * 'a -> (svalue,'a) token\r
        val RBKT : 'a * 'a -> (svalue,'a) token\r
        val LBKT : 'a * 'a -> (svalue,'a) token\r
        val SELECT : 'a * 'a -> (svalue,'a) token\r
        val INCLUDE : 'a * 'a -> (svalue,'a) token\r
        val WIRE : 'a * 'a -> (svalue,'a) token\r
        val COMMA : 'a * 'a -> (svalue,'a) token\r
        val DOT : 'a * 'a -> (svalue,'a) token\r
        val EQUAL : 'a * 'a -> (svalue,'a) token\r
        val RANGLE : 'a * 'a -> (svalue,'a) token\r
        val LANGLE : 'a * 'a -> (svalue,'a) token\r
        val LPAREN : 'a * 'a -> (svalue,'a) token\r
        val RPAREN : 'a * 'a -> (svalue,'a) token\r
      end\r
    structure ParserData :\r
      sig\r
        type pos\r
        type svalue\r
        type arg\r
        type result\r
        structure LrTable : <sig>\r
        structure Token : <sig>\r
        structure Actions : <sig>\r
        structure EC : <sig>\r
        val table : LrTable.table\r
        sharing LrTable = Token.LrTable\r
      end\r
    sharing type Tokens.svalue = ParserData.svalue\r
    sharing type Tokens.token = ParserData.Token.token\r
  end\r
val it = () : unit\r
\[opening ruby.lex.sml\]\r
\[autoloading\]\r
\[autoloading done\]\r
ruby.lex.sml:54.5-55.21 Warning: match nonexhaustive\r
          \"T\" => ...\r
          \"F\" => ...\r
  \r
functor RubyLexFun(<param>: sig\r
                              structure Tokens : <sig>\r
                            end) :\r
                  sig\r
                    structure UserDeclarations : <sig>\r
                    exception LexError\r
                    structure Internal : <sig>\r
                    val makeLexer : (int -> string) -> unit -> Internal.result\r
                  end\r
val it = () : unit\r
\[opening ruby.yacc.sml\]\r
functor RubyLrValsFun(<param>: sig\r
                                 structure Token : <sig>\r
                               end) :\r
                     sig\r
                       structure ParserData : <sig>\r
                       structure Tokens : <sig>\r
                     end\r
val it = () : unit\r
\[opening ruby.sml\]\r
structure ruby :\r
  sig\r
    structure RubyLrVals : <sig>\r
    structure RubyLex : <sig>\r
    structure RubyParser : <sig>\r
    val invoke : (RubyParser.svalue,RubyParser.pos) LrParser.Token.token \r
                   ?.LrParser.stream\r
                 -> RubyParser.result * \r
                    (RubyParser.svalue,RubyParser.pos) LrParser.Token.token \r
                      ?.LrParser.stream\r
    val input_line : TextIO.instream -> int -> string\r
    val parse : string -> RubyParser.result\r
  end\r
val it = () : unit\r
\[opening circuittype.sml\]\r
structure Circuittype :\r
  sig\r
    datatype device\r
      = ABS\r
      | AD\r
      | ADD\r
      | AND\r
      | BIT2SINT of int\r
      | BIT2SREAL of int * int\r
      | BIT2UINT of int\r
      | BIT2UREAL of int * int\r
      | BTOI\r
      | D\r
      | DEC\r
      | DEVICE of string\r
      | DI of const\r
      | DIV\r
      | EQ\r
      | EXP\r
      | FAC\r
      | GCD\r
      | GE\r
      | GT\r
      | IF\r
      | INC\r
      | INT2REAL\r
      | ITOB\r
      | LE\r
      | LOG\r
      | LT\r
      | MAX\r
      | MIN\r
      | MOD\r
      | MULT\r
      | MUX of int\r
      | NAND\r
      | NOR\r
      | NOT\r
      | NOTHING\r
      | OR\r
      | PDSR of int\r
      | REAL2INT\r
      | SDPR of int\r
      | SINT2BIT of int\r
      | SREAL2BIT of int * int\r
      | SUB\r
      | UINT2BIT of int\r
      | UREAL2BIT of int * int\r
      | XNOR\r
      | XOR\r
    datatype exprtype\r
      = CON of const\r
      | EXPR of expr\r
      | LIST of expr list\r
      | WIRE of dir * int * int\r
    datatype dir = IN | OUT | POLY\r
    type expr = exprtype ref\r
    type gate = device * expr * expr\r
    type relation = gate list\r
    type circuit = expr * expr * relation\r
    type pcircuit = expr * expr * relation list\r
  end\r
val it = () : unit\r
opening Circuittype\r
  \r
  datatype device\r
    = ABS\r
    | AD\r
    | ADD\r
    | AND\r
    | BIT2SINT of int\r
    | BIT2SREAL of int * int\r
    | BIT2UINT of int\r
    | BIT2UREAL of int * int\r
    | BTOI\r
    | D\r
    | DEC\r
    | DEVICE of string\r
    | DI of const\r
    | DIV\r
    | EQ\r
    | EXP\r
    | FAC\r
    | GCD\r
    | GE\r
    | GT\r
    | IF\r
    | INC\r
    | INT2REAL\r
    | ITOB\r
    | LE\r
    | LOG\r
    | LT\r
    | MAX\r
    | MIN\r
    | MOD\r
    | MULT\r
    | MUX of int\r
    | NAND\r
    | NOR\r
    | NOT\r
    | NOTHING\r
    | OR\r
    | PDSR of int\r
    | REAL2INT\r
    | SDPR of int\r
    | SINT2BIT of int\r
    | SREAL2BIT of int * int\r
    | SUB\r
    | UINT2BIT of int\r
    | UREAL2BIT of int * int\r
    | XNOR\r
    | XOR\r
  datatype exprtype\r
    = CON of const\r
    | EXPR of Circuittype.expr\r
    | LIST of Circuittype.expr list\r
    | WIRE of Circuittype.dir * int * int\r
  datatype dir = IN | OUT | POLY\r
  type expr = Circuittype.exprtype ref\r
  type gate = Circuittype.device * Circuittype.expr * Circuittype.expr\r
  type relation = Circuittype.gate list\r
  type circuit = Circuittype.expr * Circuittype.expr * Circuittype.relation\r
  type pcircuit =\r
    Circuittype.expr * Circuittype.expr * Circuittype.relation list\r
\[opening exprs.sml\]\r
structure Exprs :\r
  sig\r
    val MonoWireCount : int ref\r
    val PolyWireCount : int ref\r
    val con : const -> expr\r
    val monoIn : int -> expr\r
    val monoOut : int -> expr\r
    val poly : int -> expr\r
    val monoInList : int -> int -> expr list\r
    val monoOutList : int -> int -> expr list\r
    val polyList : int -> int -> expr list\r
    val list : expr list -> expr\r
    val exprInputs : expr -> int list\r
    val exprOutputs : expr -> int list\r
    val exprWires : expr -> expr list\r
    val flattenExpr : expr -> exprtype list\r
    val endCount : expr -> int\r
  end\r
val it = () : unit\r
opening Exprs\r
  val MonoWireCount : int ref\r
  val PolyWireCount : int ref\r
  val con : const -> expr\r
  val monoIn : int -> expr\r
  val monoOut : int -> expr\r
  val poly : int -> expr\r
  val monoInList : int -> int -> expr list\r
  val monoOutList : int -> int -> expr list\r
  val polyList : int -> int -> expr list\r
  val list : expr list -> expr\r
  val exprInputs : expr -> int list\r
  val exprOutputs : expr -> int list\r
  val exprWires : expr -> expr list\r
  val flattenExpr : expr -> exprtype list\r
  val endCount : expr -> int\r
\[opening values.sml\]\r
structure Values :\r
  sig\r
    datatype value = ...\r
    val CONSTANT : const -> value\r
    val CIRCUIT : (unit -> circuit) -> value\r
    val FUNCTION : (value -> value) -> value\r
    val value2circuit : value -> circuit\r
    val value2const : value -> const\r
    val value2bool : value -> bool\r
    val value2num : value -> const\r
    val value2int : value -> int\r
    val value2nat : value -> int\r
    val apply : value * value list -> value * value list\r
  end\r
val it = () : unit\r
opening Values\r
  datatype value = ...\r
  val CONSTANT : const -> value\r
  val CIRCUIT : (unit -> circuit) -> value\r
  val FUNCTION : (value -> value) -> value\r
  val value2circuit : value -> circuit\r
  val value2const : value -> const\r
  val value2bool : value -> bool\r
  val value2num : value -> const\r
  val value2int : value -> int\r
  val value2nat : value -> int\r
  val apply : value * value list -> value * value list\r
\[opening show.sml\]\r
\[autoloading\]\r
\[autoloading done\]\r
show.sml:32.5-76.88 Warning: match nonexhaustive\r
          D => ...\r
          DI k => ...\r
          MUX n => ...\r
          SDPR n => ...\r
          PDSR n => ...\r
          NOT => ...\r
          AND => ...\r
          OR => ...\r
          XOR => ...\r
          NAND => ...\r
          NOR => ...\r
          XNOR => ...\r
          LT => ...\r
          GT => ...\r
          LE => ...\r
          GE => ...\r
          EQ => ...\r
          IF => ...\r
          BTOI => ...\r
          ITOB => ...\r
          ADD => ...\r
          SUB => ...\r
          MULT => ...\r
          DIV => ...\r
          MOD => ...\r
          EXP => ...\r
          LOG => ...\r
          MAX => ...\r
          MIN => ...\r
          GCD => ...\r
          FAC => ...\r
          DEC => ...\r
          INC => ...\r
          AD => ...\r
          ABS => ...\r
          REAL2INT => ...\r
          INT2REAL => ...\r
          BIT2UINT n => ...\r
          BIT2SINT n => ...\r
          UINT2BIT n => ...\r
          SINT2BIT n => ...\r
          BIT2UREAL (m,n) => ...\r
          BIT2SREAL (m,n) => ...\r
          UREAL2BIT (m,n) => ...\r
          SREAL2BIT (m,n) => ...\r
  \r
structure Show :\r
  sig\r
    val showConst : const -> string\r
    val showDevice : device -> string\r
  end\r
val it = () : unit\r
opening Show\r
  val showConst : const -> string\r
  val showDevice : device -> string\r
\[opening compose.sml\]\r
compose.sml:63.5-107.40 Warning: match nonexhaustive\r
          (CON (BOOL a),CON (BOOL b)) => ...\r
          (CON (INT a),CON (INT b)) => ...\r
          (CON (REAL a),CON (REAL b)) => ...\r
          (CON (SYM a),CON (SYM b)) => ...\r
          (CON _,WIRE (OUT,_,_)) => ...\r
          (CON _,WIRE _) => ...\r
          (CON _,LIST _) => ...\r
          (WIRE (OUT,_,_),CON _) => ...\r
          (WIRE _,CON _) => ...\r
          (WIRE (OUT,_,_),WIRE (OUT,_,_)) => ...\r
          (WIRE (OUT,_,_),WIRE _) => ...\r
          (WIRE (IN,_,_),WIRE (OUT,_,_)) => ...\r
          (WIRE (IN,_,_),WIRE _) => ...\r
          (WIRE (POLY,_,e),_) => ...\r
          (WIRE _,LIST _) => ...\r
          (LIST _,CON _) => ...\r
          (LIST _,WIRE (POLY,_,e)) => ...\r
          (LIST _,WIRE _) => ...\r
          (LIST xs,LIST ys) => ...\r
          (EXPR e,_) => ...\r
          (_,EXPR e) => ...\r
  \r
structure Compose :\r
  sig\r
    val par : circuit list -> circuit\r
    val seq : circuit * circuit -> circuit\r
  end\r
val it = () : unit\r
opening Compose\r
  val par : circuit list -> circuit\r
  val seq : circuit * circuit -> circuit\r
\[opening compileExp.sml\]\r
structure CompileExp :\r
  sig val exp2value : string -> (string -> value) -> exp -> value end\r
val it = () : unit\r
opening CompileExp\r
  val exp2value : string -> (string -> value) -> exp -> value\r
\[opening wiringPrims.sml\]\r
structure WiringPrims : sig val append : int * int -> value end\r
val it = () : unit\r
opening WiringPrims\r
  val append : int * int -> value\r
\[opening arithPrims.sml\]\r
arithPrims.sml:112.5-115.81 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:107.5-110.75 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:102.5-105.74 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:97.5-100.75 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:92.5-95.74 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:84.5-87.68 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:79.5-82.68 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:70.5-77.121 Warning: match nonexhaustive\r
          (_,INT 0) => ...\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:65.5-68.62 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:60.5-63.62 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:55.5-58.62 Warning: match nonexhaustive\r
          (INT n1,INT n2) => ...\r
          (INT n1,REAL n2) => ...\r
          (REAL n1,INT n2) => ...\r
          (REAL n1,REAL n2) => ...\r
  \r
arithPrims.sml:52.5-53.52 Warning: match nonexhaustive\r
          INT n => ...\r
          REAL n => ...\r
  \r
structure ArithPrims :\r
  sig\r
    val arithNeg : const -> value\r
    val arithPlus : const * const -> value\r
    val arithMinus : const * const -> value\r
    val arithTimes : const * const -> value\r
    val arithDivide : const * const -> value\r
    val arithMax : const * const -> value\r
    val arithMin : const * const -> value\r
    val arithMod : int * int -> value\r
    val arithGtn : const * const -> value\r
    val arithGeq : const * const -> value\r
    val arithLtn : const * const -> value\r
    val arithLeq : const * const -> value\r
    val arithEq : const * const -> value\r
    val arithNot : int -> value\r
  end\r
val it = () : unit\r
opening ArithPrims\r
  val arithNeg : const -> value\r
  val arithPlus : const * const -> value\r
  val arithMinus : const * const -> value\r
  val arithTimes : const * const -> value\r
  val arithDivide : const * const -> value\r
  val arithMax : const * const -> value\r
  val arithMin : const * const -> value\r
  val arithMod : int * int -> value\r
  val arithGtn : const * const -> value\r
  val arithGeq : const * const -> value\r
  val arithLtn : const * const -> value\r
  val arithLeq : const * const -> value\r
  val arithEq : const * const -> value\r
  val arithNot : int -> value\r
\[opening primTypes.sml\]\r
structure PrimTypes :\r
  sig\r
    val unary : device -> value\r
    val binary : device -> value\r
    val ternary : device -> value\r
    val unary_k : (const -> device) -> value\r
    val i_ins_one_out : (int -> device) -> value\r
    val one_in_i_outs : (int -> device) -> value\r
    val ij_ins_one_out : (int * int -> device) -> value\r
    val one_in_ij_outs : (int * int -> device) -> value\r
    val one_and_i_ins_one_out : (int -> device) -> value\r
    val num_prim : (const -> value) -> value\r
    val num_num_prim : (const * const -> value) -> value\r
    val nat_prim : (int -> value) -> value\r
    val nat_nat_prim : (int * int -> value) -> value\r
    val int_prim : (int -> value) -> value\r
    val int_int_prim : (int * int -> value) -> value\r
  end\r
val it = () : unit\r
opening PrimTypes\r
  val unary : device -> value\r
  val binary : device -> value\r
  val ternary : device -> value\r
  val unary_k : (const -> device) -> value\r
  val i_ins_one_out : (int -> device) -> value\r
  val one_in_i_outs : (int -> device) -> value\r
  val ij_ins_one_out : (int * int -> device) -> value\r
  val one_in_ij_outs : (int * int -> device) -> value\r
  val one_and_i_ins_one_out : (int -> device) -> value\r
  val num_prim : (const -> value) -> value\r
  val num_num_prim : (const * const -> value) -> value\r
  val nat_prim : (int -> value) -> value\r
  val nat_nat_prim : (int * int -> value) -> value\r
  val int_prim : (int -> value) -> value\r
  val int_int_prim : (int * int -> value) -> value\r
\[opening data.sml\]\r
structure Data :\r
  sig\r
    val DATA_alx_clk : string ref\r
    val DATA_blk_clk : string ref\r
    val DATA_blk_clk_ena : string ref\r
    val DATA_blk_domain_io : io ref\r
    val DATA_blk_range_io : io ref\r
    val DATA_xnf_clk : string ref\r
    val DATA_xnf_clk_ena : string ref\r
    val DATA_xnf_out_ena : string ref\r
    val DATA_xnf_domain_io : io ref\r
    val DATA_xnf_range_io : io ref\r
    val DATA_xnf_header : string ref\r
    val recordData : string * io -> unit\r
  end\r
val it = () : unit\r
opening Data\r
  val DATA_alx_clk : string ref\r
  val DATA_blk_clk : string ref\r
  val DATA_blk_clk_ena : string ref\r
  val DATA_blk_domain_io : io ref\r
  val DATA_blk_range_io : io ref\r
  val DATA_xnf_clk : string ref\r
  val DATA_xnf_clk_ena : string ref\r
  val DATA_xnf_out_ena : string ref\r
  val DATA_xnf_domain_io : io ref\r
  val DATA_xnf_range_io : io ref\r
  val DATA_xnf_header : string ref\r
  val recordData : string * io -> unit\r
\[opening compileDef.sml\]\r
structure CompileDef :\r
  sig\r
    val storeDef : defn -> unit\r
    val globalDef : string -> value\r
  end\r
val it = () : unit\r
opening CompileDef\r
  val storeDef : defn -> unit\r
  val globalDef : string -> value\r
\[opening ioAlias.sml\]\r
structure IoAlias :\r
  sig val ioAlias : string * expr * io -> (exprtype * io) list end\r
val it = () : unit\r
opening IoAlias\r
  val ioAlias : string * expr * io -> (exprtype * io) list\r
\[opening printrbs.sml\]\r
structure Printrbs : sig val showRBS : pcircuit -> string end\r
val it = () : unit\r
opening Printrbs\r
  val showRBS : pcircuit -> string\r
\[opening printalx.sml\]\r
printalx.sml:60.5-61.24 Warning: match nonexhaustive\r
          IN => ...\r
          OUT => ...\r
  \r
structure Printalx : sig val showALX : string -> pcircuit -> string end\r
val it = () : unit\r
opening Printalx\r
  val showALX : string -> pcircuit -> string\r
\[opening printblk.sml\]\r
printblk.sml:38.5-39.41 Warning: match nonexhaustive\r
          VAR s => ...\r
          CONST k => ...\r
  \r
printblk.sml:26.19-35.74 Warning: match nonexhaustive\r
          CON (BOOL false) => ...\r
          CON (BOOL true) => ...\r
          CON (INT 0) => ...\r
          CON (INT 1) => ...\r
          CON (SYM \"?\") => ...\r
          CON k => ...\r
          WIRE (_,n,_) => ...\r
  \r
structure Printblk : sig val showBLK : pcircuit -> string end\r
val it = () : unit\r
opening Printblk\r
  val showBLK : pcircuit -> string\r
\[opening printxnf.sml\]\r
printxnf.sml:47.5-48.25 Warning: match nonexhaustive\r
          CONST k => ...\r
          VAR s => ...\r
  \r
printxnf.sml:38.5-45.66 Warning: match nonexhaustive\r
          CON (BOOL false) => ...\r
          CON (BOOL true) => ...\r
          CON (INT 0) => ...\r
          CON (INT 1) => ...\r
          CON (SYM \"?\") => ...\r
          CON k => ...\r
          WIRE (_,n,_) => ...\r
  \r
structure Printxnf : sig val showXNF : pcircuit -> string end\r
val it = () : unit\r
opening Printxnf\r
  val showXNF : pcircuit -> string\r
\[opening ednlib\]\r
structure Library : sig val lib : string end\r
val it = () : unit\r
opening Library\r
  val lib : string\r
\[opening printedf.sml\]\r
printedf.sml:121.15-229.12 Warning: match nonexhaustive\r
          D => ...\r
          DI k => ...\r
          MUX 2 => ...\r
          AND => ...\r
          NOR => ...\r
          OR => ...\r
          XOR => ...\r
          NOT => ...\r
  \r
printedf.sml:99.14-113.43 Warning: match nonexhaustive\r
          CON k => ...\r
          WIRE (IN,name,_) => ...\r
          WIRE (OUT,name,_) => ...\r
          LIST es => ...\r
          EXPR x => ...\r
  \r
printedf.sml:65.29 Warning: calling polyEqual\r
printedf.sml:54.6-54.34 Warning: match nonexhaustive\r
          x :: y :: z :: zs => ...\r
  \r
printedf.sml:53.13-53.36 Warning: match nonexhaustive\r
          x :: y :: ys => ...\r
  \r
printedf.sml:52.6-52.24 Warning: match nonexhaustive\r
          x :: xs => ...\r
  \r
structure Printedf : sig val showEDF : pcircuit -> string end\r
val it = () : unit\r
opening Printedf\r
  val showEDF : pcircuit -> string\r
\[opening vhdlib\]\r
structure VHDL_Library :\r
  sig\r
    val vhdl_not : string\r
    val vhdl_and : string\r
    val vhdl_or : string\r
    val vhdl_xor : string\r
    val vhdl_conf_xor : string\r
    val vhdl_conf_and : string\r
    val vhdl_conf_or : string\r
    val vhdl_conf_not : string\r
    val lib : (string * string) list\r
  end\r
val it = () : unit\r
opening VHDL_Library\r
  val vhdl_not : string\r
  val vhdl_and : string\r
  val vhdl_or : string\r
  val vhdl_xor : string\r
  val vhdl_conf_xor : string\r
  val vhdl_conf_and : string\r
  val vhdl_conf_or : string\r
  val vhdl_conf_not : string\r
  val lib : (string * string) list\r
\[opening printvhd.sml\]\r
structure PrintVhdl : sig val printVHDL : pcircuit -> string end\r
val it = () : unit\r
opening PrintVhdl\r
  val printVHDL : pcircuit -> string\r
\[opening printvlg.sml\]\r
structure PrintVerilog : sig val printVerilog : pcircuit -> string end\r
val it = () : unit\r
opening PrintVerilog\r
  val printVerilog : pcircuit -> string\r
\[opening printmax.sml\]\r
printmax.sml:34.5-78.91 Warning: match nonexhaustive\r
          D => ...\r
          DI k => ...\r
          MUX n => ...\r
          SDPR n => ...\r
          PDSR n => ...\r
          NOT => ...\r
          AND => ...\r
          OR => ...\r
          XOR => ...\r
          NAND => ...\r
          NOR => ...\r
          XNOR => ...\r
          LT => ...\r
          GT => ...\r
          LE => ...\r
          GE => ...\r
          EQ => ...\r
          IF => ...\r
          BTOI => ...\r
          ITOB => ...\r
          ADD => ...\r
          SUB => ...\r
          MULT => ...\r
          DIV => ...\r
          MOD => ...\r
          EXP => ...\r
          LOG => ...\r
          MAX => ...\r
          MIN => ...\r
          GCD => ...\r
          FAC => ...\r
          DEC => ...\r
          INC => ...\r
          AD => ...\r
          ABS => ...\r
          REAL2INT => ...\r
          INT2REAL => ...\r
          BIT2UINT n => ...\r
          BIT2SINT n => ...\r
          UINT2BIT n => ...\r
          SINT2BIT n => ...\r
          BIT2UREAL (m,n) => ...\r
          BIT2SREAL (m,n) => ...\r
          UREAL2BIT (m,n) => ...\r
          SREAL2BIT (m,n) => ...\r
  \r
structure PrintMax : sig val showMax : pcircuit -> string end\r
val it = () : unit\r
opening PrintMax\r
  val showMax : pcircuit -> string\r
\[opening order.sml\]\r
structure Order : sig val circuit2pcircuit : circuit -> pcircuit end\r
val it = () : unit\r
opening Order\r
  val circuit2pcircuit : circuit -> pcircuit\r
\[opening main.sml\]\r
structure Main :\r
  sig\r
    val rc : string * string list -> int\r
    val rcHandle : string list * string list -> unit\r
  end\r
val it = () : unit\r
opening Main\r
  val rc : string * string list -> int\r
  val rcHandle : string list * string list -> unit\r
\[autoloading\]\r
\[autoloading done\]\r
\[80G  \r\[1;43madvantage: ~/ruby/compiler% \[0m \[80G  \r> "
send -- "exit\r"
expect eof
